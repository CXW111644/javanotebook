#### 垃圾回收算法  

###### 标记----清除（Mark—Sweep）

标记：遍历所有的根对象，通过引用链追踪所有可达的对象，标记上存活，未标记的就是垃圾对象即不可达对象

清除：在清除阶段 ，垃圾回收器会遍历队中的所有对象，回收那些没有未被标记的对象，这些对象的内存空间会被释放，返回给堆内存池

缺点：效率低，时间复杂度高，产生了内存碎片，影响后续对象的分配效率，停顿时间长

###### 复制算法（Copying）

适合年轻代垃圾回收

将堆内存分为两个相等的区域，只使用其中一个区域，当这个区域内存用完时，垃圾回收器会将所有活动对象复制到另一个区域，重置原区域的所有内存

缺点：内存可使用少，垃圾回收频率提高，

###### 标记----整理（Mark-Compact）

适合老年代垃圾回收

标记：与标记清除算法一致，，遍历所有根对象遍历到的标记为存活

整理：对堆中的存活对象进行压缩和移动，按顺序排列在对的一端，留下连续的空闲内存空间,移动到一端避免内存碎片的问题

优点：

- 消除内存碎片，通过整理队中的存活对象，使内存空间连续，避免内存碎片化
- 提高内存利用率
- 减少停顿时间，只需要移动一次对象，而不是多次清除

缺点：

- 对象移动的开销增大
- 复杂度较高
- 停顿时间不可预测

#### 经典垃圾回收器

##### CMS

初始标记

标记一下连接GC Roots的一些对象，由于数量少所以速度很快，需要停顿

并发标记

进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，需要将所有的科大状态对象进行扫描，时间较长，不需要停顿。

重新标记

在并发标记阶段，可能存在一些对象的引用发生变化，这些变化可能导致一些对象没有被标记。因此，JVM 在并发标记阶段结束后，会进行一次重新标记（Remark）过程来重新标记这些遗漏的对象。需要停顿

重新标记阶段是同步的

并发清除

在这个阶段，JVM 会回收那些未被标记的对象，同时继续与应用程序线程并发执行。不需要停顿 

CMS算法的 缺点：

吞吐量低，低停顿牺牲了吞吐量

无法处理浮动垃圾"Concurrent Mode Failure"（并发模式失败）











































