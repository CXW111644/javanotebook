### 对象的生命周期

##### 创建阶段

- 给对象分配空间
- 开始构造对象
- 从超类到子类对static成员进行初始化
- 超类成员变量按照顺序初始化，递归调用超累的构造方法
- 子类成员变量按顺序初始化，子类构造方法调用（构造方法初始化之前需要先初始化变量）

##### 应用阶段

对象至少被一个强引用者持有

##### 不可见阶段

在不可见阶段中，不再有强引用者持有，但是这个对象还存在，

这个程序的执行已经超过了该对象的作用域

申请交由一个类似数组的表中，存储地址指向该对象，这个表作为强引用者，所以这个对象对于GC来说是不可回收的，

##### 不可达阶段

在不可见阶段中，如果不需要的对象时，只需要将这个对象在表中的地址值设置为null，那么就没有指针指向当前对象，就变成了可回收对象，即不可达阶段

##### 收集阶段

对象处于不可达阶段中，垃圾回收器已经对该对象的内存空间重新分配做好准备，即对象处于收集阶段

重载finazlie（）方法的坏处

1. 影响jvm对象分配和回收速度，增加了垃圾回收的开销，
2. 可能造成对象的再次复活
3. 易引发内存泄漏，如果在finalize()方法中引用了某些资源，而这些资源又依赖于垃圾回收器的行为，可能导致对象无法及时回收，从而形成内存泄漏

##### 终结阶段

对象执行完finazline（）方法后如果处于不可达状态，则对象进入终结阶段，等待垃圾回收器对该对象进行回收

##### 对象空间重新分配阶段

垃圾回收处理之后对该对象所占用的内存进行重新分配，即该对象彻底消息

#### 对象生成到死亡的整个过程

![image-20241226224027984](C:\Users\陈宣玮\AppData\Roaming\Typora\typora-user-images\image-20241226224027984.png)

##### 在堆空间中分为年轻代和老年代

###### 年轻代

​	Eden区

​		年轻代的主要区域，是 Java 垃圾回收机制中用于存放新创建对象的地方，新创建对象会被分配到Eden区，Eden区是最大的内存区域。

​	Survivor 1 区（S1，From 区）

​		年轻一代的存活区域之一，存放第一次GC之后存活的对象，

​	Survivor 2 区（S1，To 区）

​		另一个年轻一代的存活区域，这边存放从from 区中经过GC之后存活的年轻代

​	每一次GC，都会将对象在S1与S2中来回互换，直到足够老时，晋升为老年代

###### 	老年代

​		那些在年轻代垃圾回收中多次存活并且长时间活跃的对象将晋升为老年代，同时内存较大的对象将直接存储到老年代，

​		老年代的垃圾回收：垃圾回收不频繁，但一旦发生垃圾回收（称为 Full GC 或 Major GC），开销较大，因为需要检查并回收老年代中的所有对象，会导致 长时间的停顿，因为对应用程序的影响较大

​		垃圾回收触发条件：老年代内存不足或者 JVM 检测到需要回收老年代时。Major GC 会回收整个堆，包括年轻代和老年代。

​		为什么会回收整个堆：（可能需要将年轻代中的一部分对象晋升到老年代，因此老年代的回收会考虑到整个堆中的对象，确保内存的有效管理。）

#### GC判断策略

###### 引用计数算法

给对象加一个引用计算器（未绑定即计数器为0），当对象增加引用时计时器+1，当引用失效时计数器-1，计数器为0时该对象会被回收，，

有一种情况，两个对象会循环引用（相互引用），导致计数器永不为0，永远不会被GC清理，所以jvm不用引用计数器

###### 可达性分析算法

可达性分析算法通过从一组称为 GC Roots的对象开始，沿着对象之间的引用关系进行图遍历，如果一个对象能 从GC Roots通过一系列引用链到达，那么他是可达的，如果不能到达那么是不可达的，将会被回收